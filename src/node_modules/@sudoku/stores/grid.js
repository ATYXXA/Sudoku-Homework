import { BOX_SIZE, SUDOKU_SIZE } from '@sudoku/constants';
import { decodeSencode, encodeSudoku } from '@sudoku/sencode';
import { generateSudoku } from '@sudoku/sudoku';
import { derived, writable, get } from 'svelte/store';
import { hints } from './hints';
import { undoStack, redoStack , canUndo, canRedo , recallStack_toundo , recallStack_toredo , canRecall  , recall_times} from './history';
import { candidates } from './candidates.js';
import { SudokuStrategyFactory } from '@sudoku/strategies'
// import { strategy } from '@sudoku/strategies'

function createGrid() {
	const grid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	return {
		subscribe: grid.subscribe,

		generate(difficulty) {
			grid.set(generateSudoku(difficulty));
		},

		decodeSencode(sencode) {
			grid.set(decodeSencode(sencode));
		},

		get(gridStore, x, y) {
			return gridStore[y][x];
		},

		getSencode(gridStore) {
			return encodeSudoku(gridStore);
		},
	};
}

export const grid = createGrid();

// Deep clone function for grid state
function cloneGrid(gridState) {
    return gridState.map(row => [...row]);
}

function createUserGrid() {
	const userGrid = writable([
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
		[0, 0, 0, 0, 0, 0, 0, 0, 0],
	]);

	grid.subscribe($grid => {
		let newGrid = [];

		for (let y = 0; y < SUDOKU_SIZE; y++) {
			newGrid[y] = [];
			for (let x = 0; x < SUDOKU_SIZE; x++) {
				newGrid[y][x] = $grid[y][x];
			}
		}

		userGrid.set(newGrid);
	});

	return {
		subscribe: userGrid.subscribe,

		set(pos, value) {
			const currentState = cloneGrid(get(userGrid));		
			userGrid.update(grid => {
				const possibleValues = getPossibleValues(grid, pos.y, pos.x);
				const possibleValues_length = possibleValues.length;
				console.log("possibleValues: ", possibleValues);
				console.log("possibleValues_length: ", possibleValues_length);

				grid[pos.y][pos.x] = value;
				// Save current state to undo stack before making changes
				undoStack.update(stack => {
					stack.push(currentState);
					return stack;
				});
				// Clear redo stack when new move is made
				redoStack.set([]);
				// 设置recallStack_undo
				recallStack_toundo.update(stack => {
					stack.push(possibleValues_length);

					return stack;
				});
				// 设置 recallStack_redo
				recallStack_toredo.set([]);

				if (possibleValues_length > 1){
					recall_times.update(currentValue => currentValue + 1);
				}
				else{
					// nothing to do
				}
				canRecall.set(get(recall_times) >= 1);

				canUndo.set(get(undoStack).length > 0);
				canRedo.set(get(redoStack).length > 0);

				console.log("\nset number :");
				console.log("undoStack.stack: ", get(undoStack));
				console.log("recallStack_toundo.stack: ", get(recallStack_toundo));
				console.log("recall_times: ", get(recall_times));

				return grid;
			});
		},

		undo() {
			undoStack.update(stack => {
				if (stack.length === 0) return stack;
				const previousState = stack.pop();

				recallStack_toundo.update(stack => {
					// 弹出最新入栈的值
					const pop_previous_value = stack.pop();
					// 将弹出的值赋给 previousState_possibleValues
					let previousState_possibleValues = pop_previous_value;
					
					// 检查 previousState_possibleValues 的值
					if (previousState_possibleValues > 1) {
						recall_times.update(currentValue => currentValue - 1);
					}
					
					// 将弹出的值放入 redo stack
					recallStack_toredo.update(recallStack_toredo => {
						recallStack_toredo.push(previousState_possibleValues);
						return recallStack_toredo;
					});
				
					// 返回更新后的 undo stack
					return stack;
				});

				// Save current state to redo stack
				redoStack.update(redoStack => {
					redoStack.push(cloneGrid(get(userGrid)));
					return redoStack;
				});

				// Restore previous state
				userGrid.set(previousState);

				canUndo.set(stack.length > 0);
				canRedo.set(get(redoStack).length > 0);
				canRecall.set(get(recall_times) >= 1);

				console.log("\nundo :");
				console.log("undoStack.stack: ", get(undoStack));
				console.log("redoStack.stack: ", get(redoStack));
				console.log("recallStack_toundo.stack: ", get(recallStack_toundo));
				console.log("recallStack_toredo.stack: ", get(recallStack_toredo));
				console.log("recall_times: ", get(recall_times));

				return stack;
			});
		},

		redo() {
			redoStack.update(stack => {
				if (stack.length === 0) return stack;
				const nextState = stack.pop();

				recallStack_toredo.update(stack => {
					// 弹出最新入栈的值
					const pop_previous_value = stack.pop();
					// 将弹出的值赋给 previousState_possibleValues
					let previousState_possibleValues = pop_previous_value;
					
					// 检查 previousState_possibleValues 的值
					if (previousState_possibleValues > 1) {
						recall_times.update(currentValue => currentValue + 1);
					}
					
					// 将弹出的值放入 undo stack
					recallStack_toundo.update(recallStack_toundo => {
						recallStack_toundo.push(previousState_possibleValues);
						return recallStack_toundo;
					});
				
					// 返回更新后的 undo stack
					return stack;
				});

				// const previousState_possibleValues = recallStack_toredo.pop();
				// if(previousState_possibleValues > 1){
					
				// 	recall_times.update(currentValue => currentValue + 1);
				// }
				
				// // Save current state to redo stack
				// recallStack_toundo.update(recallStack_toundo => {
				// 	recallStack_toundo.push(previousState_possibleValues);
				// 	return recallStack_toundo;
				// });


				// Save current state to undo stack
				undoStack.update(undoStack => {
					undoStack.push(cloneGrid(get(userGrid)));
					return undoStack;
				});

				// Restore next state
				userGrid.set(nextState);

				canUndo.set(get(undoStack).length > 0);
				canRedo.set(stack.length > 0);
				canRecall.set(get(recall_times) >= 1);

				
				console.log("\nredo :");
				console.log("undoStack.stack: ", get(undoStack));
				console.log("redoStack.stack: ", get(redoStack));
				console.log("recallStack_toundo.stack: ", get(recallStack_toundo));
				console.log("recallStack_toredo.stack: ", get(recallStack_toredo));
				console.log("recall_times: ", get(recall_times));


				return stack;
			});
		},

	 	recall() {
			recallStack_toundo.update(stack => {
				if (stack.length === 0) return stack;

				// 先保存最新状态
				redoStack.update(redoStack => {
					redoStack.push(cloneGrid(get(userGrid)));
					return redoStack;
				});
		
				while (true) {

					undoStack.update(stack => {
						// 弹出最新入栈的值
						// 从 undoStack 中弹出最新状态
						const previousState = stack.pop();
						// 将弹出的值赋给 previousState_possibleValues
						let now_previousState = previousState;
						// 将弹出的状态和值分别推入 redoStack 和 recallStack_toredo
						redoStack.update(redoStack => {
							redoStack.push(now_previousState);
							return redoStack;
						});

						// 恢复到之前的状态
						userGrid.set(now_previousState);
					
						// 返回更新后的 undo stack
						return stack;
					});
		
					// 从 recallStack_toundo 中弹出最新值
					const previousState_possibleValues = stack.pop();
					recallStack_toredo.update(recallStack_toredo => {
						recallStack_toredo.push(previousState_possibleValues);
						return recallStack_toredo;
					});
		
					// 检查 previousState_possibleValues 的值
					if (previousState_possibleValues > 1) {
						// 更新 recall_times 和 canRecall
						recall_times.update(currentValue => currentValue - 1);
						canRecall.set(get(recall_times) >= 1);
						break;
					} else {
						// 更新 canRecall
						canRecall.set(get(recall_times) >= 1);
					}
				}

				// 多进来了一个
				redoStack.update(stack => {
					// 弹出最新入栈的值
					const pop_previous_value = stack.pop();
				
					// 返回更新后的 undo stack
					return stack;
				});
		
				// 更新 canUndo, canRedo, canRecall
				canUndo.set(get(undoStack).length > 0);
				canRedo.set(get(redoStack).length > 0);
				canRecall.set(get(recall_times) >= 1);
		
				console.log("\nrecall :");
				console.log("undoStack.stack: ", get(undoStack));
				console.log("redoStack.stack: ", get(redoStack));
				console.log("recallStack_toundo.stack: ", get(recallStack_toundo));
				console.log("recallStack_toredo.stack: ", get(recallStack_toredo));
				console.log("recall_times: ", get(recall_times));

				return stack;
			});
		},

		check_can_recall(){
			canRecall.set(get(recall_times) >= 1);
		},

		applyHint: () => {
			hints.useHint();    // Decrement hints
            if(hints.gethints() <= 0){  // 取消提示
                candidates.clear();
                return;
            }
			userGrid.update($userGrid => {           
                // console.log("原始棋盘\n",$userGrid);
                // 检查棋盘中所有空着的位置中，每个位置对于数独要求来说只能够填写一个数字的格子
                const uniqueCells = getHintCells($userGrid);
                // console.log("uniqueCells:\n", uniqueCells);
                
                // 在棋盘中用绿色背景显示这些格子，并显示这些格子可以填写的数字
                // console.log("candidates: ", candidates);
                candidates.clear();
                uniqueCells.forEach(cell => {
                    // 添加新的候选值到指定格子的候选值数组中
                    // console.log("cell: ", cell);
                    let x = cell.x;
                    let y = cell.y;
                    let value = cell.value;
                    candidates.add({x:x, y:y}, value);  // candidate要反过来
                });
                // console.log("candidates: ", candidates);
                return $userGrid;
			});
		},

		// applyStrategy() {
		// 	userGrid.update($userGrid => {
		// 		// 保存原始网格的副本
		// 		const originalGrid = JSON.stringify($userGrid);
		
		// 		// 解题
		// 		const solvedSudoku = strategy.solve($userGrid);
		
		// 		// 比较解决后的网格和原始网格
		// 		if (JSON.stringify(solvedSudoku) === originalGrid) {
		// 			// 弹窗提示
		// 			alert('当前策略找不到解！');
		// 		}
		// 		return solvedSudoku;
		// 	});
		// }

		applyStrategy(strategyName = 'x-wing') {
			userGrid.update($userGrid => {
				const factory = new SudokuStrategyFactory();
				const strategy = factory.createStrategy(strategyName);
		
				// 保存原始网格的副本
				const originalGrid = JSON.stringify($userGrid);
		
				// 解题
				const solvedSudoku = strategy.solve($userGrid);
		
				// 比较解决后的网格和原始网格
				if (JSON.stringify(solvedSudoku) === originalGrid) {
					// 弹窗提示
					alert('当前策略找不到解！');
				}
		
				return solvedSudoku;
			});
		}
		

//不要使用循环解题，目前无解的情况会卡死
		// applyStrategy(strategyName = 'x-wing', stepByStep = true) {
		// 	userGrid.update($userGrid => {
		// 		const factory = new SudokuStrategyFactory();
		// 		const strategy = factory.createStrategy(strategyName);

		// 		let solvedGrid = strategy.solve($userGrid);
		
		// 		if (stepByStep) {
		// 			while (!strategy.isSolved(solvedGrid)) {
		// 				solvedGrid = strategy.solve(solvedGrid);
		// 			}
		// 			return solvedGrid;
		// 		}		
		// 		return solvedGrid;
		// 	});
		// }
		
	};
}

// 获取棋盘中所有空着的位置中，每个位置对于数独要求来说只能够填写一个数字的格子
function getHintCells(grid) {
  const uniqueCells = [];
  for (let x = 0; x < 9; x++) {
    for (let y = 0; y < 9; y++) {
      if (grid[x][y] === 0) {
        const possibleValues = getPossibleValues(grid, x, y);
        if (possibleValues.length <= hints.gethints()) {
            possibleValues.forEach(value => {
              uniqueCells.push({ x, y, value});
            });
        }
      }
    }
  }
//   console.log("num_null_cells: ", num_null_cells); 
  return uniqueCells;
}

// 获取一个格子可以填写的数字
function getPossibleValues(grid, x, y) {
  const possibleValues = [];
  for (let i = 1; i <= 9; i++) {
    if (isValid(grid, x, y, i)) {
      possibleValues.push(i);
    }
  }
  return possibleValues;
}

// 检查一个数字是否可以填写在一个格子中
function isValid(grid, x, y, value) {
  // 检查行和列中是否已经存在这个数字
  for (let i = 0; i < 9; i++) {
    if (grid[x][i] === value || grid[i][y] === value) {
      return false;
    }
  }
  
  // 检查 3x3 的宫格中是否已经存在这个数字
  const startRow = Math.floor(x / 3) * 3;
  const startCol = Math.floor(y / 3) * 3;
  for (let i = 0; i < 3; i++) {
    for (let j = 0; j < 3; j++) {
      if (grid[startRow + i][startCol + j] === value) {
        return false;
      }
    }
  }
  
  return true;
}

export const userGrid = createUserGrid();

export const invalidCells = derived(userGrid, $userGrid => {
	const _invalidCells = [];

	const addInvalid = (x, y) => {
		const xy = x + ',' + y;
		if (!_invalidCells.includes(xy)) _invalidCells.push(xy);
	};

	for (let y = 0; y < SUDOKU_SIZE; y++) {
		for (let x = 0; x < SUDOKU_SIZE; x++) {

			const value = $userGrid[y][x];

			if (value) {
				for (let i = 0; i < SUDOKU_SIZE; i++) {
					// Check the row
					if (i !== x && $userGrid[y][i] === value) {
						addInvalid(x, y);
					}

					// Check the column
					if (i !== y && $userGrid[i][x] === value) {
						addInvalid(x, i);
					}
				}

				// Check the box
				const startY = Math.floor(y / BOX_SIZE) * BOX_SIZE;
				const endY = startY + BOX_SIZE;
				const startX = Math.floor(x / BOX_SIZE) * BOX_SIZE;
				const endX = startX + BOX_SIZE;
				for (let row = startY; row < endY; row++) {
					for (let col = startX; col < endX; col++) {
						if (row !== y && col !== x && $userGrid[row][col] === value) {
							addInvalid(col, row);
						}
					}
				}
			}

		}
	}

	return _invalidCells;
}, []);