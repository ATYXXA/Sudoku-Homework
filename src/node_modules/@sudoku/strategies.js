// import { hints } from './hints';
class SudokuStrategy {
    solve(grid) {
        throw new Error('This method must be overridden by subclasses');
    }

    // 检查在 (row, col) 位置放置 num 是否合法
    isSafe(grid, row, col, num) {
        // 检查行
        for (let i = 0; i < 9; i++) {
            if (grid[row][i] === num) return false;
        }
        // 检查列
        for (let i = 0; i < 9; i++) {
            if (grid[i][col] === num) return false;
        }
        // 检查 3x3 宫格
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (grid[startRow + i][startCol + j] === num) return false;
            }
        }
        return true;
    }

    // 辅助函数：检查数独是否已解决
    isSolved(grid) {
        // 检查是否有未填的格子
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (grid[i][j] === 0) return false;
            }
        }


        // 检查是否满足数独规则
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                const num = grid[i][j];
                grid[i][j] = 0;
                if (!this.isSafe(grid, i, j, num)) return false;
                grid[i][j] = num;
            }
        }


        return true;
    }

    // 找出每个空格的候选数
    findCandidates(grid) {
        const candidates = [];
        for (let i = 0; i < 9; i++) {
            candidates.push([]);
            for (let j = 0; j < 9; j++) {
                if (grid[i][j] === 0) {
                    const possible = [];
                    for (let num = 1; num <= 9; num++) {
                        if (this.isSafe(grid, i, j, num)) {
                            possible.push(num);
                        }
                    }
                    candidates[i].push(possible);
                } else {
                    candidates[i].push([]);
                }
            }
        }
        return candidates;
    }
}

class XWingStrategy extends SudokuStrategy {

    // 查找并应用 X-Wing 模式
    findXWing(candidates) {
        const steps = [];

        const processXWing = (isRow) => {
            for (let num = 1; num <= 9; num++) {
                for (let i1 = 0; i1 < 9; i1++) {
                    for (let i2 = i1 + 1; i2 < 9; i2++) {
                        const positions1 = [];
                        const positions2 = [];
                        for (let j = 0; j < 9; j++) {
                            const pos1 = isRow ? candidates[i1][j] : candidates[j][i1];
                            const pos2 = isRow ? candidates[i2][j] : candidates[j][i2];
                            if (pos1.includes(num)) positions1.push(j);
                            if (pos2.includes(num)) positions2.push(j);
                        }

                        if (
                            positions1.length === 2 &&
                            positions2.length === 2 &&
                            ((positions1[0] === positions2[0] && positions1[1] === positions2[1]) ||
                                (positions1[0] === positions2[1] && positions1[1] === positions2[0]))
                        ) {
                            // 找到 X-Wing 模式
                            const affected = [];
                            for (let i = 0; i < 9; i++) {
                                if (i !== i1 && i !== i2) {
                                    positions1.forEach((j) => {
                                        const index = isRow ? candidates[i][j].indexOf(num) : candidates[j][i].indexOf(num);
                                        if (index !== -1) {
                                            affected.push({ i, j, num });
                                            if (isRow) candidates[i][j].splice(index, 1);
                                            else candidates[j][i].splice(index, 1);
                                        }
                                    });
                                }
                            }

                            if (affected.length > 0) {
                                steps.push({
                                    type: "x-wing",
                                    num,
                                    positions: { i1, i2, positions1 },
                                    affected,
                                });
                            }
                        }
                    }
                }
            }
        };

        processXWing(true); // 行检查
        processXWing(false); // 列检查

        return steps;
    }

    applyXWing(grid) {
        console.log('applyXWing');
        let candidates = this.findCandidates(grid);
        const steps = this.findXWing(candidates);

        steps.forEach((step) => {
            console.log(step);
            step.affected.forEach(({ i, j, num }) => {
                const index = candidates[i][j].indexOf(num);
                if (index !== -1) {
                    candidates[i][j].splice(index, 1);
                }
            });
        });

        // 填入唯一候选数
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (candidates[i][j].length === 1) {
                    grid[i][j] = candidates[i][j][0];
                }
            }
        }

        return { grid, steps };
    }

    solve(grid) {
        console.log('进入 solve 函数');
        let modified = true;
        while (modified) {
            const prevGrid = grid;
            grid = this.applyXWing(grid).grid;
            modified = prevGrid !== grid;
        }
        return grid;
    }
}

class SudokuStrategyFactory {
    createStrategy(strategyName) {
        switch (strategyName) {
            case 'x-wing':
                return new XWingStrategy();
            // 添加更多策略
            default:
                throw new Error(`Strategy ${strategyName} not found`);
        }
    }
}

module.exports = {
    SudokuStrategyFactory,
    XWingStrategy,
};
