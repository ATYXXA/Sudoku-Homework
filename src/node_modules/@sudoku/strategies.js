// import { writable } from'svelte/store';
// import { STRATEGIES } from '@sudoku/constants';
class SudokuStrategy {
    solve(grid) {
        console.log('This method must be overridden by subclasses');
        return grid;
    }

    // 检查在 (row, col) 位置放置 num 是否合法
    isSafe(grid, row, col, num) {
        // 检查行
        for (let i = 0; i < 9; i++) {
            if (grid[row][i] === num) return false;
        }
        // 检查列
        for (let i = 0; i < 9; i++) {
            if (grid[i][col] === num) return false;
        }
        // 检查 3x3 宫格
        const startRow = Math.floor(row / 3) * 3;
        const startCol = Math.floor(col / 3) * 3;
        for (let i = 0; i < 3; i++) {
            for (let j = 0; j < 3; j++) {
                if (grid[startRow + i][startCol + j] === num) return false;
            }
        }
        return true;
    }

    isSolved(grid) {
        // 检查是否有未填的格子
        for (let i = 0; i < 9; i++) {
            for (let j = 0; i < 9; j++) {
                if (grid[i][j] === 0) return false;
            }
        }
        // 检查每行是否包含 1-9
        for (let i = 0; i < 9; i++) {
            const rowSet = new Set();
            for (let j = 0; j < 9; j++) {
                rowSet.add(grid[i][j]);
            }
            if (rowSet.size!== 9) return false;
        }
        // 检查每列是否包含 1-9
        for (let j = 0; j < 9; j++) {
            const colSet = new Set();
            for (let i = 0; i < 9; i++) {
                colSet.add(grid[i][j]);
            }
            if (colSet.size!== 9) return false;
        }
        // 检查每个 3x3 宫格是否包含 1-9
        for (let blockRow = 0; blockRow < 3; blockRow++) {
            for (let blockCol = 0; blockCol < 3; blockCol++) {
                const blockSet = new Set();
                for (let i = blockRow * 3; i < (blockRow + 1) * 3; i++) {
                    for (let j = blockCol * 3; j < (blockCol + 1) * 3; j++) {
                        blockSet.add(grid[i][j]);
                    }
                }
                if (blockSet.size!== 9) return false;
            }
        }
        return true;
    }

    // 找出每个空格的候选数
    findCandidates(grid) {
        const candidates = [];
        for (let i = 0; i < 9; i++) {
            candidates.push([]);
            for (let j = 0; j < 9; j++) {
                if (grid[i][j] === 0) {
                    const possible = [];
                    for (let num = 1; num <= 9; num++) {
                        if (this.isSafe(grid, i, j, num)) {
                            possible.push(num);
                        }
                    }
                    candidates[i].push(possible);
                } else {
                    candidates[i].push([]);
                }
            }
        }
        return candidates;
    }
}

class XWingStrategy extends SudokuStrategy {

    // 查找并应用 X-Wing 模式
    findXWing(candidates) {
        const steps = [];

        const processXWing = (isRow) => {
            for (let num = 1; num <= 9; num++) {
                for (let i1 = 0; i1 < 9; i1++) {
                    for (let i2 = i1 + 1; i2 < 9; i2++) {
                        const positions1 = [];
                        const positions2 = [];
                        for (let j = 0; j < 9; j++) {
                            const pos1 = isRow ? candidates[i1][j] : candidates[j][i1];
                            const pos2 = isRow ? candidates[i2][j] : candidates[j][i2];
                            if (pos1.includes(num)) positions1.push(j);
                            if (pos2.includes(num)) positions2.push(j);
                        }

                        if (
                            positions1.length === 2 &&
                            positions2.length === 2 &&
                            ((positions1[0] === positions2[0] && positions1[1] === positions2[1]) ||
                                (positions1[0] === positions2[1] && positions1[1] === positions2[0]))
                        ) {
                            // 找到 X-Wing 模式
                            const affected = [];
                            for (let i = 0; i < 9; i++) {
                                if (i !== i1 && i !== i2) {
                                    positions1.forEach((j) => {
                                        const index = isRow ? candidates[i][j].indexOf(num) : candidates[j][i].indexOf(num);
                                        if (index !== -1) {
                                            affected.push({ i, j, num });
                                            if (isRow) candidates[i][j].splice(index, 1);
                                            else candidates[j][i].splice(index, 1);
                                        }
                                    });
                                }
                            }

                            if (affected.length > 0) {
                                steps.push({
                                    type: "x-wing",
                                    num,
                                    positions: { i1, i2, positions1 },
                                    affected,
                                });
                            }
                        }
                    }
                }
            }
        };

        processXWing(true); // 行检查
        processXWing(false); // 列检查

        return steps;
    }

    applyXWing(grid) {
        console.log('applyXWing');
        let candidates = this.findCandidates(grid);
        const steps = this.findXWing(candidates);

        steps.forEach((step) => {
            console.log(step);
            step.affected.forEach(({ i, j, num }) => {
                const index = candidates[i][j].indexOf(num);
                if (index !== -1) {
                    candidates[i][j].splice(index, 1);
                }
            });
        });

        // 填入唯一候选数
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (candidates[i][j].length === 1) {
                    grid[i][j] = candidates[i][j][0];
                }
            }
        }

        return { grid, steps };
    }

    solve(grid) {
        console.log('进入 solve 函数');
        let modified = true;
        while (modified) {
            const prevGrid = grid;
            grid = this.applyXWing(grid).grid;
            modified = prevGrid !== grid;
        }
        return grid;
    }
}

class RectangleEliminationStrategy extends SudokuStrategy {
    // 检查是否存在矩形消除的模式
    findRectangleElimination(candidates) {
        const steps = [];
        for (let num = 1; num <= 9; num++) {
            // 遍历所有单元格，寻找可能的铰链单元格
            for (let row = 0; row < 9; row++) {
                for (let col = 0; col < 9; col++) {
                    if (candidates[row][col].includes(num)) {
                        // 假设当前单元格为铰链单元格
                        const hingeRow = row;
                        const hingeCol = col;
                        // 寻找与铰链单元格在同一行（或列）的另一个单元格（强链接）
                        let strongLinkRow = -1;
                        let strongLinkCol = -1;
                        for (let i = 0; i < 9; i++) {
                            if (i!== col && candidates[row][i].includes(num)) {
                                strongLinkRow = row;
                                strongLinkCol = i;
                                break;
                            }
                            if (i!== row && candidates[i][col].includes(num)) {
                                strongLinkRow = i;
                                strongLinkCol = col;
                                break;
                            }
                        }
                        if (strongLinkRow!== -1 && strongLinkCol!== -1) {
                            // 寻找与铰链单元格在相反方向（列或行）且在另一个弱链接宫格中的单元格
                            const oppositeRow = strongLinkRow === row? -1 : strongLinkRow;
                            const oppositeCol = strongLinkCol === col? -1 : strongLinkCol;
                            const boxRow = Math.floor(hingeRow / 3);
                            const boxCol = Math.floor(hingeCol / 3);
                            const oppositeBoxRow = Math.floor(oppositeRow / 3);
                            const oppositeBoxCol = Math.floor(oppositeCol / 3);
                            if (oppositeRow!== -1 && oppositeCol!== -1 && (boxRow * 3 + boxCol)!== (oppositeBoxRow * 3 + oppositeBoxCol)) {
                                // 寻找可以进行消除的单元格
                                const eliminateRow = oppositeRow === -1? row : oppositeRow;
                                const eliminateCol = oppositeCol === -1? col : oppositeCol;
                                for (let i = 0; i < 9; i++) {
                                    if (i!== hingeCol && i!== strongLinkCol && candidates[eliminateRow][i].includes(num)) {
                                        const affected = {
                                            row: eliminateRow,
                                            col: i,
                                            num: num
                                        };
                                        steps.push({
                                            type: "rectangle-elimination",
                                            num: num,
                                            hinge: { row: hingeRow, col: hingeCol },
                                            strongLink: { row: strongLinkRow, col: strongLinkCol },
                                            affected: [affected]
                                        });
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return steps;
    }

    applyRectangleElimination(grid) {
        console.log('applyRectangleElimination');
        let candidates = this.findCandidates(grid);
        const steps = this.findRectangleElimination(candidates);

        steps.forEach((step) => {
            console.log(step);
            step.affected.forEach(({ row, col, num }) => {
                const index = candidates[row][col].indexOf(num);
                if (index!== -1) {
                    candidates[row][col].splice(index, 1);
                }
            });
        });

        // 填入唯一候选数
        for (let i = 0; i < 9; i++) {
            for (let j = 0; j < 9; j++) {
                if (candidates[i][j].length === 1) {
                    grid[i][j] = candidates[i][j][0];
                }
            }
        }

        return { grid, steps };
    }

    solve(grid) {
        console.log('进入 RectangleEliminationStrategy 的 solve 函数');
        let modified = true;
        while (modified) {
            const prevGrid = grid;
            grid = this.applyRectangleElimination(grid).grid;
            modified = prevGrid!== grid;
        }
        return grid;
    }
}

class SudokuStrategyFactory {
    createStrategy(strategyName) {
        switch (strategyName) {
            case 'x-wing':
                return new XWingStrategy();
            case 'rectangle-elimination':
                return new RectangleEliminationStrategy();
            // 添加更多策略
            default:
                throw new Error(`Strategy ${strategyName} not found`);
        }
    }
}

module.exports = {
    SudokuStrategyFactory,
};







